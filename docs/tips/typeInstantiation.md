## ジェネリックのインスタンス化のタイプ

たとえば、ジェネリックパラメータを持つものがあるとします。クラス `Foo`：

```ts
class Foo<T>{
	foo: T;
}
```

特定のタイプの特殊バージョンを作成したいとします。このパターンは、項目を新しい変数にコピーし、ジェネリックを具体的な型に置き換えて型の注釈を与えることです。例えば。 `Foo <number>`クラスが必要な場合：

```ts
class Foo<T>{
	foo: T;
}
let FooNumber = Foo as { new ():Foo<number> }; // ref 1
```
`ref 1 'では、`FooNumber`は `Foo`と同じですが、`new`演算子で呼び出されたときに `Foo <Number>`のインスタンスを与えるものとして扱います。

### 継承
タイプアサーションパターンは、あなたが正しいことを信じているという意味では安全ではありません。クラス*の他の言語*の共通パターンは継承を使うことです：

```ts
class FooNumber extends Foo<number>{}
```

ここで注意しなければならないのは、デコレータを基本クラスで使用すると、継承されたクラスは基本クラスと同じ動作をしない可能性があります(デコレータによってラップされなくなりました)。

もちろん、クラスを専門化していない場合でも、強制的な/強制的なパターンが必要です。そのため、最初に一般的なアサーションパターンを示しました。

```ts
function id<T>(x: T) { return x; }
const idNum = id as {(x:number):number};
```

> この[インストゥルメントフローの質問]に触発された(http://stackoverflow.com/a/34864705/390330)
