## `export default`は問題につながります

以下の内容の `foo.ts`ファイルがあるとします：

```ts
class Foo {
}
export default Foo;
```

次のように、ES6構文を使用して（bar.tsで）インポートします。

```ts
import Foo from "./foo";
```

メンテナンスの問題がいくつかあります：
* `foo.ts`で`Foo`をリファクタリングすると `bar.ts`に名前を変更しません。
* `foo.ts`から多くのものをエクスポートする必要がある場合（これはあなたのファイルの多くが持っているものです）、インポート構文をじゃまにする必要があります。

このため、私は単純な輸出+非構造化輸入をお勧めします。例えば。 `foo.ts`：

```ts
export class Foo {
}
```
その後：

```ts
import {Foo} from "./foo";
```

> **ボーナスポイント**：デフォルトのエクスポートでは検出可能性が非常に悪いです。インテリセンスを持つモジュールを探索して、デフォルトの書き出しがあるかどうかを調べることはできません。

> **ボーナスポイント**： "./foo"; "カーソル位置からこの` import {/ *ここに*}}でオートコンプリートさえさえします。あなたの開発者に少しの手首の安堵感を与えます。

> **ボーナスポイント**：より良いcommonJSの経験。 `default`を使うと、`const {Foo} = require（ 'module / foo'）の代わりに `const {default} = require（`module / foo '）; `を実行するcommonJSユーザにとって恐ろしい経験があります`

> **ボーナスポイント**：あなたは `dev 'のようなタイプミスを`./foo'から ``import Foo '; ``や ``foo "` `from foo" ``

> **ボーナスポイント**：自動インポートクイックフィックスが効果的です。あなたは `Foo`を使用し、自動インポートは`./foo ";から` import {Foo} 'を書き留めて、モジュールからエクスポートされた明確に定義された名前にします。

> **ボーナスポイント**：再輸出は不必要に困難です。例えば、npmパッケージのルート `index`ファイルには、再エクスポートが一般的です。 `Fooを" ./foo "からインポートする。 export {Foo} `（デフォルト）と`。* foo '`からのエクスポート*（名前付きエクスポート）
